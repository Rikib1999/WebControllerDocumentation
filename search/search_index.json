{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This application allows you to monitor and interact with Unity game sessions in real-time via a web interface. You can view active and inactive sessions, send commands, and visualize player positions on a map. The WebController is a client-server application designed to enable real-time communication between Unity applications (clients) and a Vue.js frontend via a Flask backend using WebSockets (Socket.IO). The application is containerized using Docker for ease of deployment.</p> <p>This solution consists of a web application and a Unity package. The web application includes a frontend and a server. In the web application, the user can see a list of all currently connected Unity sessions as well as a list of past, inactive sessions. Upon selecting a session from the list, its details are displayed. The session detail view shows basic information about the session. The detail view includes a control panel consisting of buttons that represent commands sent to the Unity session. These buttons may also have text fields for command input. The session detail also displays data received from the Unity session in real-time, organized into lists based on data types. Additionally, the detail view shows a map of the currently running level in the Unity session, displaying the positions, rotations, and paths of the player and other objects in the scene in real-time. A Unity session can be controlled indefinitely using only the control panel, within the scope of the Unity package implementation in the given project. The session details can be saved to a file in JSON format.</p> <p>The Unity package in the session automatically connects to the server when the project is launched and immediately appears in the list of active sessions. Implementing the Unity package into a project is simple and does not require any changes or adjustments to the project\u2019s logic. The package consists of 5 scripts. The main script is a manager script where the connection parameters to the server are configured. Receiving events from the server is handled by a separate script, where the names of the received commands are defined along with their corresponding reactions in the form of Unity events. Sending data about the positions of the player and other objects is also managed by a separate script, where it is only necessary to pass references to the respective objects and the player. Sending custom data to the server is done via a static method through code, with data always sent as a key-value pair of string type.</p> <p>For more information on the functionality and control of the application, please refer to the section Manual.</p>"},{"location":"#github-repositories","title":"Github repositories","text":"<ul> <li>WebController: https://github.com/cyberspace-lab/cyberframe-webcontroller</li> <li>Unity package: https://github.com/cyberspace-lab/cyberframe-webcontroller-unitypackage</li> </ul>"},{"location":"#dependencies","title":"Dependencies","text":"<ul> <li>SocketIOUnity by itisnajim: https://github.com/itisnajim/SocketIOUnity</li> </ul>"},{"location":"#application-architecture","title":"Application Architecture","text":"<p>The Web Controller Application is built on a client-server architecture:</p> <ul> <li>Frontend: Implemented using Vue.js framework.</li> <li>Backend: Utilizes Flask, a Python web framework.</li> <li>Communication: Real-time, two-way communication using WebSockets via Socket.IO.</li> <li>Reverse Proxy: Nginx is used to proxy requests between clients and the server.</li> <li>Unity Integration: Unity game sessions act as clients communicating with the server.</li> <li>Containerization: The application is dockerized for easy deployment.</li> </ul>"},{"location":"#main-features","title":"Main Features","text":"<ul> <li> <p>Active and Inactive Session Management   Easy tracking of game sessions with separate lists for active and inactive ones. Includes detailed logs like experiment name, device ID, timestamps, and options to save session data.</p> </li> <li> <p>Live Map View   Displays player and object positions on a map in real-time, showing movement paths and directions. Supports switching maps for different levels.</p> </li> <li> <p>Customizable Control Panel   Context-sensitive control panel to manage experiments, offering actions like starting, stopping, resetting, or moving players. Includes dynamic parameter inputs for flexible command execution.</p> </li> <li> <p>Data Display and Organization   Real-time data from sessions is shown clearly and grouped by type, with limits on how much past data is stored.</p> </li> <li> <p>Automatic Session Management   Automated saving of sessions on disconnection and memory cleanup to maintain system performance. Sessions are stored on disk and can be exported as JSON.</p> </li> <li> <p>Flexible Configuration Options   Fully configurable via JSON file, allowing easy customization of button actions, data types, level maps, and memory thresholds without additional coding.</p> </li> <li> <p>Multi-Client and Experiment Support   Supports multiple simultaneous sessions, diverse experiment types, and multiple frontend instances for scalable use cases.</p> </li> <li> <p>Connection State Monitoring   Tracks connection events like reconnecting or disconnecting, so experiments can react or notify users if needed.</p> </li> </ul>"},{"location":"#how-does-it-work","title":"How does it work","text":"<p>The frontend of the web application is implemented in Vue.js. Server is implemented with Flask. Unity sessions with the implemented package and Vue frontends act as clients for the Flask server. Server and clients are communicating via websockets. Server is updating all clients with new data but only one specific Unity client to which a command was sent, this means that different clients can have identical commands but sending it to one of them wont affect others.</p> <p>Web application needs to be configured with the configuration file. In this file is a list of different Unity experiments the application can communicate with. Experiment is defined by its name, command buttons, receivers and maps. Command button is defined by the name of the button shown in the control panel, name of the command and its static or dynamic parameters. Static parameters are defined in the config. For a dynamic parameter that will be taken as an input from a textbox, button should be configured accordingly. Receivers are names of the data types or categories that could be received from a Unity session and shown in the session detail. The maps section of the configuration defines pictures of different levels with their dimensions and IDs.</p> <p>Frontend will dynamically create buttons and textboxes in the control panel of the session detail page based on the configuration. Categorized lists of the received data will also be created along with the correct map picture rendered. </p> <p>Server stores all the data in a dictionary like structure. It has a dictionary of all Unity sessions where the sessions device ID is the key. This dictionary stores all received data and additional inforamtion about a session. Server is automatically managing this dictionary and deleting older records (number of history records are defined in the configuration file).</p> <p>When the user click on a command button in the control panel, server send the given command with its parameters to the Unity client which will handle it by a script named GenericEventListener. Unity is sending data to the server with the ID of the sessions device, name of the data type sent is the key and the data is the value. Server will receive this data, update its dictionary of the sessions data and propagate this update to all the frontend clients.</p>"},{"location":"ActiveSessionDetail/","title":"Active Session Detail","text":"<p><code>ActiveSessions.vue</code> component manages the detailed view of an active session for a specific device. It displays session information, controls, real-time session updates, and provides features such as map visualization and session data export. The component communicates with the backend via WebSockets.</p>"},{"location":"ActiveSessionDetail/#features","title":"Features","text":"<ul> <li>Session Details: Shows session name, device ID, start time, and last ping.</li> <li>Control Panel: Provides dynamic buttons for sending commands to the server.</li> <li>Real-Time Data Updates: Updates session data and UI elements live using WebSocket events.</li> <li>Map Visualization: Displays positions using the <code>LatestPositions</code> component.</li> <li>Session Data: Allows users to view session data in key-value pairs with a toggle option to reveal all values.</li> <li>Session Export: Allows users to download session details in JSON format.</li> <li>Contextual Filtering of Control Buttons: Control buttons are filtered based on the current session's context. If the session doesn't match the button's required context, the button will not be displayed.</li> </ul>"},{"location":"ActiveSessionDetail/#logic-overview","title":"Logic Overview","text":""},{"location":"ActiveSessionDetail/#props","title":"Props","text":"<ul> <li><code>deviceId</code>: The unique ID of the device whose session details are being viewed.</li> </ul>"},{"location":"ActiveSessionDetail/#data","title":"Data","text":"<ul> <li>session: The current active session object.</li> <li>applications: List of available applications loaded from a configuration file.</li> <li>sessionData: Real-time data associated with the current session.</li> <li>showAllValuesToggle: Reactive object to manage visibility of extra session data values.</li> <li>dynamicInputs: Array of inputs linked to control buttons requiring user input.</li> </ul>"},{"location":"ActiveSessionDetail/#computed-properties","title":"Computed Properties","text":"<ul> <li>application: Retrieves the current application based on the session name.</li> <li>filteredControlButtons: Filters control buttons based on the current session context.</li> <li>currentContext: Parses and returns the session's context as an array.</li> <li>parsedPositions: Parses position data for rendering on the map.</li> <li>filteredPositionsByLevelID: Filters device positions based on the current level ID.</li> <li>filteredSessionData: Excludes position and context data for displaying the session\u2019s key-value pairs.</li> <li>currentLevelID: Extracts the current level ID from parsed positions.</li> <li>currentMapUrl: URL of the map image for the current level.</li> <li>realMapWidth: Real width of the map for the current level.</li> <li>realMapHeight: Real height of the map for the current level.</li> <li>shouldRenderLatestPositions: Determines if the LatestPositions component should be rendered.</li> <li>mapOffsetX, mapOffsetY, mapOffsetRotation: Offset values for positioning and rotating the map.</li> </ul>"},{"location":"ActiveSessionDetail/#methods","title":"Methods","text":"<ul> <li>goToActiveSessions: Navigates back to the active sessions list.</li> <li>handleButtonClick: Handles button clicks and sends commands to the server with the associated payload and user input.</li> <li>toggleShowAllValues: Toggles the visibility of additional values for session data keys.</li> <li>handleUnityDisconnected: Handles the disconnection of the Unity application, resetting session data and redirecting to a different view.</li> <li>handleSession: Handles receiving session data from the server and updates the component's session state.</li> <li>handleSessionDataKeyUpdate: Updates specific session data in real-time.</li> <li>emitGetActiveSession: Requests the active session details from the server.</li> <li>saveSessionAsJson: Saves the session data as a JSON file for download.</li> </ul>"},{"location":"ActiveSessionDetail/#socket-events","title":"Socket Events","text":"<ul> <li>connect: Emits the <code>get_active_session</code> event when the socket connects.</li> <li>active_session: Receives active session data from the server.</li> <li>session_data_key_update: Updates session data with real-time changes.</li> <li>unity_disconnected: Handles the disconnection of the Unity application.</li> </ul>"},{"location":"ActiveSessionDetail/#ui-elements","title":"UI Elements","text":"<ul> <li>Session Details Section:</li> <li>Displays session information, including session name, device ID, start time, and last ping.</li> <li> <p>Buttons to save session data or navigate back to active sessions.</p> </li> <li> <p>Map Section:</p> </li> <li> <p>Displays device positions on the map, including dynamic offsets and rendering options.</p> </li> <li> <p>Control Panel:</p> </li> <li> <p>Displays buttons for controlling the session, including input fields for commands requiring user input.</p> </li> <li> <p>Session Data Section:</p> </li> <li>Displays session data in key-value pairs with toggle functionality to show all values for a given key.</li> </ul>"},{"location":"ActiveSessions/","title":"Active Sessions List","text":"<p>The <code>ActiveSessions.vue</code> file is a Vue.js component designed to manage and display active sessions. It utilizes Socket.IO for real-time updates and offers navigation to both detailed views of active sessions and a list of inactive sessions.</p>"},{"location":"ActiveSessions/#features","title":"Features","text":"<ul> <li>Navigation: Allows navigation to the session details page of each active session and to the inactive sessions page.</li> <li>Active Sessions List: Shows session details such as session name, device ID, start time, and last ping. Each session links to a detail view.</li> <li>No Sessions Message: Displays a message when no active sessions are available.</li> <li>Real-Time Updates: Updates the active sessions list in real time when new data is received.</li> </ul>"},{"location":"ActiveSessions/#logic-overview","title":"Logic Overview","text":""},{"location":"ActiveSessions/#data","title":"Data","text":"<ul> <li>activeSessions: An object that holds the active session data, indexed by device ID.</li> </ul>"},{"location":"ActiveSessions/#methods","title":"Methods","text":"<ul> <li>goToInactiveSessions: Navigates to the inactive sessions page when the corresponding button is clicked.</li> <li>handleActiveSessionsUpdate: Updates the <code>activeSessions</code> data when the 'active_sessions_update' event is received from the server.</li> </ul>"},{"location":"ActiveSessions/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<ul> <li>mounted: Emits an event to fetch the active session data as soon as the component is mounted. Listens for the <code>active_sessions_update</code> event to update the session list.</li> <li>beforeUnmount: Removes the event listener for the <code>active_sessions_update</code> event before the component is destroyed.</li> </ul>"},{"location":"ActiveSessions/#ui-elements","title":"UI Elements","text":"<ul> <li>Banner: A banner displaying the title \"Active Sessions\" and a button to navigate to the inactive sessions page.</li> <li>Session List: A list of active sessions, where each item displays:</li> <li>Session Name: The name of the active session.</li> <li>Device ID: The unique ID of the device.</li> <li>Start Time: The start time of the session.</li> <li>Last Ping: The time of the last ping received.</li> <li>View Detail: A link to view detailed information about the session.</li> <li>No Active Sessions Message: A message shown if there are no active sessions.</li> </ul>"},{"location":"ActiveSessions/#socket-events","title":"Socket Events","text":"<ul> <li>get_active_sessions: Sent to request the active sessions data when the component is mounted.</li> <li>active_sessions_update: Receives updated active session data from the server, triggering the <code>handleActiveSessionsUpdate</code> method to update the active session list.</li> </ul>"},{"location":"GenericEventListener/","title":"GenericEventListener","text":"<p>The <code>GenericEventListener</code> class is designed to listen for specific events from the WebSocket server and trigger corresponding Unity events. It integrates Unity's event system with WebSocket-based events to allow for seamless communication between the server and Unity. When a relevant event is received, it invokes a Unity event with the appropriate parameters.</p>"},{"location":"GenericEventListener/#features","title":"Features","text":"<ul> <li>Dynamic Event Subscription: The class subscribes to multiple WebSocket events dynamically at runtime, based on the configuration provided in the <code>EventBag</code> array.</li> <li>Event-Driven Unity Integration: Upon receiving data from the WebSocket server, it invokes Unity events, passing the received data as parameters of type WebControllerCommand to any subscribed listeners.</li> <li>Main Thread Execution: Ensures that Unity-specific actions are executed on the main thread via the <code>UnityMainThreadDispatcher</code>, preventing issues related to multi-threading.</li> </ul>"},{"location":"GenericEventListener/#properties","title":"Properties","text":"<ul> <li>events: A serialized array of <code>EventBag</code> objects that define the WebSocket event names and the corresponding Unity events to trigger when those events occur.</li> </ul>"},{"location":"GenericEventListener/#methods","title":"Methods","text":"<ul> <li> <p>OnEnable: This method is called when the object is enabled. It subscribes to each event specified in the <code>events</code> array. When an event is received from the WebSocket server, it invokes the corresponding Unity event with the parameters provided by the server.</p> </li> <li> <p>OnDisable: This method is called when the object is disabled. It unsubscribes from all events in the <code>events</code> array, ensuring that no further events will be received or processed after the object is disabled.</p> </li> </ul>"},{"location":"GenericEventListener/#nested-classes","title":"Nested Classes","text":"<ul> <li>EventBag: A private, serializable class used to store the event name (<code>eventName</code>) and the corresponding Unity event (<code>response</code>) to trigger when the event is received from the WebSocket server.<ul> <li>eventName (string): The name of the WebSocket event to listen for.</li> <li>response (UnityEvent): The Unity event to invoke when the WebSocket event is received, with the server response wrapped in <code>WebControllerCommandParameters</code>."},{"location":"GenericEventListener/#usage","title":"Usage","text":"<ol> <li> <p>Add the Component:</p> <ul> <li>Attach the <code>GenericEventListener</code> script to a GameObject in your Unity scene.</li> </ul> </li> <li> <p>Configure Events:</p> <ul> <li>In the Inspector, expand the <code>Events</code> array.</li> <li>For each event:<ul> <li><code>Event Name</code>: Enter the name of the server event to listen for.</li> <li><code>Response</code>: Add listeners to define what should happen when the event is received.</li> </ul> </li> </ul> </li> <li> <p>Implement Responses:</p> <ul> <li>Use the UnityEvent interface to assign existing component methods, to respond to the event.</li> <li>The event response receives a <code>WebControllerCommandParameters</code> object containing the event data.</li> <li>The methods responding to the event should have either one parameter of type WebControllerCommandParameters or no parameters.</li> </ul> </li> </ol>"},{"location":"InactiveSessionDetail/","title":"Inactive Session Detail","text":"<p><code>ActiveSessions.vue</code> component provides detailed information about an inactive session associated with a specific device. It allows viewing session details, displaying a map of device positions, saving session data as a JSON file, and handling session-related actions such as deletion.</p>"},{"location":"InactiveSessionDetail/#features","title":"Features","text":"<ul> <li>Session Details: Displays session name, device ID, start time, last ping, and allows the user to save session data as JSON.</li> <li>Map Visualization: Renders a map showing device positions with dynamic offsets.</li> <li>Session Data: Displays session data in a key-value format with a toggle feature to show additional data values.</li> <li>Session Deletion: Provides a button for deleting the session.</li> <li>Real-Time Session Updates: Handles session data updates and transitions from inactive to active sessions.</li> </ul>"},{"location":"InactiveSessionDetail/#logic-overview","title":"Logic Overview","text":""},{"location":"InactiveSessionDetail/#props","title":"Props","text":"<ul> <li><code>deviceId</code>: The unique ID of the device whose inactive session details are being displayed.</li> </ul>"},{"location":"InactiveSessionDetail/#data","title":"Data","text":"<ul> <li>session: The current session object with details about the session state.</li> <li>applications: A list of available applications loaded from a configuration file.</li> <li>sessionData: Real-time data associated with the session.</li> <li>showAllValuesToggle: Reactive object controlling the visibility of extra session data values.</li> </ul>"},{"location":"InactiveSessionDetail/#computed-properties","title":"Computed Properties","text":"<ul> <li>application: Retrieves the application configuration associated with the current session name.</li> <li>parsedPositions: Parses position data for rendering on the map.</li> <li>filteredSessionData: Filters out position and context data from the session data to display other key-value pairs.</li> <li>currentLevelID: Extracts the level ID from parsed position data.</li> <li>currentMapUrl: URL of the map image for the current level.</li> <li>realMapWidth: Real width of the map for the current level.</li> <li>realMapHeight: Real height of the map for the current level.</li> <li>shouldRenderLatestPositions: Determines if the LatestPositions component should be rendered.</li> <li>mapOffsetX: Horizontal map offset for the current level.</li> <li>mapOffsetY: Vertical map offset for the current level.</li> <li>mapOffsetRotation: Rotation offset for the current map.</li> </ul>"},{"location":"InactiveSessionDetail/#methods","title":"Methods","text":"<ul> <li>goToInactiveSessions: Navigates back to the inactive sessions list.</li> <li>handleInactiveSession: Updates session details when new inactive session data is received.</li> <li>toggleShowAllValues: Toggles visibility for additional values in session data.</li> <li>handleUnityConnected: Redirects to the active session detail page when Unity connects.</li> <li>emitGetInactiveSession: Emits a request to fetch inactive session data.</li> <li>deleteSession: Deletes the current session with confirmation.</li> <li>saveSessionAsJson: Saves the session data as a downloadable JSON file.</li> </ul>"},{"location":"InactiveSessionDetail/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<ul> <li>mounted: Emits an event to fetch inactive session data after the component is mounted. Listens for incoming socket events (<code>inactive_session</code>, <code>unity_connected</code>).</li> <li>beforeUnmount: Cleans up socket event listeners before the component is destroyed.</li> </ul>"},{"location":"InactiveSessionDetail/#socket-events","title":"Socket Events","text":"<ul> <li>connect: Triggers the request for inactive session data when the socket is connected.</li> <li>inactive_session: Receives inactive session data from the server.</li> <li>unity_connected: Handles Unity application connection and redirects to the active session detail page.</li> </ul>"},{"location":"InactiveSessionDetail/#ui-elements","title":"UI Elements","text":"<ul> <li> <p>Session Details Section: Displays session information (session name, device ID, start time, last ping). Includes buttons for saving the session as JSON and navigating back to inactive sessions.</p> </li> <li> <p>Session Data Section: Displays session data in a key-value format, with a toggle to show additional values for each session data key.</p> </li> <li> <p>Delete Button: Allows the user to delete the session with confirmation.</p> </li> </ul>"},{"location":"InactiveSessions/","title":"Inactive Sessions List","text":"<p>The <code>InactiveSessions.vue</code> file is a Vue.js component for displaying inactive sessions. It provides navigation to active sessions and updates the session list in real-time via Socket.IO.</p>"},{"location":"InactiveSessions/#features","title":"Features","text":"<ul> <li>Inactive Sessions List: Displays a list of inactive sessions with session names, device IDs, start times, and last ping times.</li> <li>Navigation: Allows navigation to the session details page of each inactive session and to the active sessions page.</li> <li>No Sessions Message: Displays a message when no inactive sessions are available.</li> <li>Real-Time Updates: Updates the inactive sessions list in real time when new data is received.</li> </ul>"},{"location":"InactiveSessions/#logic-overview","title":"Logic Overview","text":""},{"location":"InactiveSessions/#data","title":"Data","text":"<ul> <li>inactiveSessions: An object that holds the inactive session data, indexed by device ID.</li> </ul>"},{"location":"InactiveSessions/#methods","title":"Methods","text":"<ul> <li>goToActiveSessions: Navigates to the active sessions page when the corresponding button is clicked.</li> <li>handleInactiveSessionsUpdate: Updates the <code>inactiveSessions</code> data when the 'inactive_sessions_update' event is received from the server.</li> </ul>"},{"location":"InactiveSessions/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<ul> <li>mounted: Emits an event to fetch the inactive session data when the component is mounted. Listens for the <code>inactive_sessions_update</code> event to update the session list.</li> <li>beforeUnmount: Removes the event listener for the <code>inactive_sessions_update</code> event before the component is destroyed.</li> </ul>"},{"location":"InactiveSessions/#ui-elements","title":"UI Elements","text":"<ul> <li>Banner: A banner displaying the title \"Inactive Sessions\" and a button to navigate to the active sessions page.</li> <li>Session List: A list of inactive sessions, where each item displays:</li> <li>Session Name: The name of the inactive session.</li> <li>Device ID: The unique ID of the device.</li> <li>Start Time: The start time of the session.</li> <li>Last Ping: The time of the last ping received.</li> <li>View Detail: A link to view detailed information about the session.</li> <li>No Inactive Sessions Message: A message shown if there are no inactive sessions.</li> </ul>"},{"location":"InactiveSessions/#socket-events","title":"Socket Events","text":"<ul> <li>get_inactive_sessions: Sent to request the inactive sessions data when the component is mounted.</li> <li>inactive_sessions_update: Receives updated inactive session data from the server, triggering the <code>handleInactiveSessionsUpdate</code> method to update the inactive session list.</li> </ul>"},{"location":"LatestPositions/","title":"Current Level Map","text":"<p><code>LatestPositions.vue</code> component is responsible for displaying the latest positions of players (or other entities) on a map. The map is represented by an image that is rendered on a canvas element, and the positions are drawn on top of the map in real time.</p>"},{"location":"LatestPositions/#features","title":"Features:","text":"<ul> <li>Map Rendering: Displays a map image scaled to fit within specified maximum dimensions while maintaining aspect ratio.</li> <li>Position Display: Plots positions on the map, representing players or objects.</li> <li>Path Drawing: Draws lines (paths) showing the movement history of each player.</li> <li>Direction Arrows: Shows the orientation of players using arrows based on rotation data.</li> <li>Dynamic Updates: Automatically updates the display when new position data or a new map is received.</li> <li>Scaling and Offsets: Adjusts positions based on real-world dimensions and optional offsets to align the map correctly.</li> </ul>"},{"location":"LatestPositions/#logic-overview","title":"Logic Overview","text":""},{"location":"LatestPositions/#props","title":"Props:","text":"<ul> <li>mapUrl: The URL of the map image to display. This is a required prop.</li> <li>realWidth: The real-world width of the map, used to calculate the scale of the map on the canvas.</li> <li>realHeight: The real-world height of the map, used to calculate the scale of the map on the canvas.</li> <li>maxWidth: The maximum width of the map on the canvas. Default is 500.</li> <li>maxHeight: The maximum height of the map on the canvas. Default is 500.</li> <li>offsetX: A horizontal offset in Unity units applied to all player positions when rendering. Default is 0.</li> <li>offsetY: A vertical offset in Unity units applied to all player positions when rendering. Default is 0.</li> <li>offsetRot: A rotation offset in degrees applied to the player positions when rendering. Default is 0.</li> <li>positions: An array of position data that includes information like coordinates (<code>posX</code>, <code>posZ</code>), rotation (<code>rotY</code>), and other player-specific data. It is required and must be passed to the component.</li> </ul> <p>The array of position objects has the following structure:</p> <pre><code>{\n  [\n    [\n      {\n        \"index\": 0,\n        \"posX\": 10,\n        \"posZ\": 20,\n        \"rotY\": 45,\n        \"latestPositionColor\": { \"r\": 255, \"g\": 0, \"b\": 0, \"a\": 1 },\n        \"olderPositionsColor\": { \"r\": 255, \"g\": 165, \"b\": 0, \"a\": 0.8 },\n        \"pathColor\": { \"r\": 255, \"g\": 165, \"b\": 0, \"a\": 0.6 }\n      },\n      // More positions...\n    ],\n    // More players...\n  ]\n}\n</code></pre>"},{"location":"LatestPositions/#data","title":"Data:","text":"<ul> <li>img: Holds the image object for the map image.</li> <li>imgWidth: The width of the map image after scaling.</li> <li>imgHeight: The height of the map image after scaling.</li> <li>scaleX: Horizontal scale factor to adjust the real-world coordinates to fit the canvas.</li> <li>scaleY: Vertical scale factor to adjust the real-world coordinates to fit the canvas.</li> </ul>"},{"location":"LatestPositions/#computed-properties","title":"Computed Properties:","text":"<ul> <li>groupedPositions: Groups the position data by player index, making it easier to manage the positions for each player.</li> </ul>"},{"location":"LatestPositions/#watchers","title":"Watchers:","text":"<ul> <li>positions: Watches for changes in the <code>positions</code> prop and updates the map when the positions are updated.</li> <li>mapUrl: Watches for changes in the <code>mapUrl</code> prop. If the map URL changes, it reloads the map image and re-renders the canvas.</li> </ul>"},{"location":"LatestPositions/#methods","title":"Methods:","text":"<ul> <li>drawMap: Draws the map image onto the canvas. It resizes the image to fit within the maximum width and height constraints while maintaining the aspect ratio.</li> <li>updateLatestPositions: Updates the canvas with the new position data. It redraws the map and then draws the new positions on top of it.</li> <li>drawPositions: Draws the paths, dots, and arrows for each player's position on the canvas. It handles grouping and rendering of player movements, colors, line widths, and direction arrows.</li> <li>drawArrowWithDot: Draws an arrow on the canvas to represent the player's direction of movement, along with a dot to represent the current position.</li> <li>setMap: Loads the map image from the provided URL, scales it to fit the canvas dimensions, and updates the canvas size and scale factors.</li> </ul>"},{"location":"LatestPositions/#lifecycle-hooks","title":"Lifecycle Hooks:","text":"<ul> <li>mounted: Calls the <code>setMap</code> method when the component is mounted to the DOM, initializing the canvas and loading the map image.</li> </ul>"},{"location":"LatestPositions/#canvas-drawing","title":"Canvas Drawing:","text":"<ul> <li>The map image is drawn on the canvas first.</li> <li>The positions are drawn on top of the map:</li> <li>Paths: A line is drawn between consecutive positions to represent the player's movement.</li> <li>Dots: A dot is drawn at each position to mark the player's location.</li> <li>Arrows: An arrow is drawn to show the direction of movement, with the rotation based on the <code>rotY</code> value.</li> </ul>"},{"location":"LatestPositions/#additional-notes","title":"Additional Notes:","text":"<ul> <li>The component supports real-time updates to the positions, with new positions being rendered as soon as they are available.</li> <li>The map is responsive, with its size adjusted based on the <code>maxWidth</code> and <code>maxHeight</code> constraints while maintaining the aspect ratio.</li> </ul>"},{"location":"LatestPositions/#usage","title":"Usage","text":"<p>To use the LatestPositions.vue component, you need to pass the required props:</p> <pre><code>&lt;LatestPositions\n  :positions=\"positionsData\"\n  :mapUrl=\"mapImageUrl\"\n  :realWidth=\"mapRealWidth\"\n  :realHeight=\"mapRealHeight\"\n  :maxWidth=\"800\"\n  :maxHeight=\"600\"\n  :offsetX=\"mapOffsetX\"\n  :offsetY=\"mapOffsetY\"\n  :offsetRot=\"mapRotationOffset\"\n/&gt;\n</code></pre>"},{"location":"PositionSender/","title":"PositionSender","text":"<p>The <code>PositionSender.cs</code> script is a Unity component designed to periodically send position and rotation data of specified transforms to a server. This synchronization allows real-time tracking of objects within a Unity scene.</p>"},{"location":"PositionSender/#purpose","title":"Purpose","text":"<p>The main purpose of the <code>PositionSender</code> script is to:</p> <ul> <li>Track multiple transforms in the Unity scene.</li> <li>Serialize their positional data along with color information.</li> <li>Send this data to a server at regular intervals using the <code>WebControllerManager</code>.</li> </ul>"},{"location":"PositionSender/#fields-and-properties","title":"Fields and Properties","text":"Field Type Description <code>currentLevelID</code> <code>int</code> Identifier for the current level or scene. <code>intervalInSeconds</code> <code>float</code> Time interval between position updates. <code>transformTrackings</code> <code>TransformTrackingBag[]</code> Array of transforms and color data to be tracked and sent."},{"location":"PositionSender/#workflow","title":"Workflow","text":"<ol> <li> <p>Initialization:</p> <ul> <li>Upon starting, the script checks if <code>transformTrackings</code> is not null or empty.</li> <li>Schedules <code>SendPositions</code> to be called repeatedly based on <code>intervalInSeconds</code>.</li> </ul> </li> <li> <p>Data Collection:</p> <ul> <li>In <code>SendPositions</code>, the script iterates over each <code>TransformTrackingBag</code> in <code>transformTrackings</code>.</li> <li>Collects position (<code>posX</code>, <code>posZ</code>), rotation (<code>rotY</code>), and color data.</li> </ul> </li> <li> <p>Serialization:</p> <ul> <li>Creates a <code>PositionBag</code> for each transform, containing all relevant data.</li> <li>Uses <code>JsonConvert.SerializeObject</code> to convert the array of <code>PositionBag</code> instances to a JSON string.</li> </ul> </li> <li> <p>Data Transmission</p> <ul> <li>Sends the JSON string to the server via <code>WebControllerManager.SendPositionData</code>.</li> </ul> </li> </ol>"},{"location":"PositionSender/#usage-example","title":"Usage Example","text":"<p>To use the <code>PositionSender</code> script:</p> <ol> <li> <p>Attach the Script:</p> <ul> <li>Add the <code>PositionSender</code> component to a GameObject in your Unity scene.</li> </ul> </li> <li> <p>Configure Fields:</p> <ul> <li>Current Level ID: Set the <code>currentLevelID</code> to uniquely identify the scene or level.</li> <li>Interval: Set <code>intervalInSeconds</code> to control how often positions are sent.</li> <li>Transforms to Track: Populate the <code>transformTrackings</code> array with the transforms you wish to monitor.</li> </ul> </li> <li> <p>Assign Colors:</p> <ul> <li>For each <code>TransformTrackingBag</code>, assign colors for:<ul> <li>Latest Position Color</li> <li>Older Positions Color</li> <li>Path Color</li> </ul> </li> </ul> </li> <li> <p>Ensure WebControllerManager is Set Up:</p> <ul> <li>Make sure the <code>WebControllerManager</code> is properly configured to handle data sending.</li> </ul> </li> </ol>"},{"location":"PositionSender/#detailed-class-and-struct-definitions","title":"Detailed Class and Struct Definitions","text":""},{"location":"PositionSender/#positionbag-struct","title":"PositionBag Struct","text":"<p>This struct encapsulates all the necessary data for a single tracked transform.</p> Field Type Description <code>levelID</code> <code>int</code> The current level or scene ID. <code>index</code> <code>int</code> Index of the transform in the tracking array. <code>posX</code> <code>float</code> X-coordinate of the transform's position. <code>posZ</code> <code>float</code> Z-coordinate of the transform's position. <code>rotY</code> <code>float</code> Y-axis rotation (Euler angle) of the transform. <code>latestPositionColor</code> <code>SerializableColor</code> Color for the latest position indicator. <code>olderPositionsColor</code> <code>SerializableColor</code> Color for older position indicators. <code>pathColor</code> <code>SerializableColor</code> Color for the path visualization."},{"location":"PositionSender/#serializablecolor-struct","title":"SerializableColor Struct","text":"<p>Converts a Unity <code>Color</code> into a format suitable for JSON serialization.</p> Field Type Description <code>r</code> <code>float</code> Red component (0-255). <code>g</code> <code>float</code> Green component (0-255). <code>b</code> <code>float</code> Blue component (0-255). <code>a</code> <code>float</code> Alpha component (0-1). <ul> <li>Constructor Logic: Multiplies RGB values by 255 to convert from Unity's 0-1 range to 0-255.</li> </ul>"},{"location":"PositionSender/#transformtrackingbag-class","title":"TransformTrackingBag Class","text":"<p>Holds reference to a transform and associated color settings.</p> Field Type Description <code>transform</code> <code>Transform</code> The transform to track. <code>latestPositionColor</code> <code>Color</code> Color for the latest position marker. <code>olderPositionsColor</code> <code>Color</code> Color for the older positions markers. <code>pathColor</code> <code>Color</code> Color for the path drawn between positions."},{"location":"UnityMainThreadDispatcher/","title":"UnityMainThreadDispatcher","text":"<p>The <code>UnityMainThreadDispatcher</code> class is designed to allow the execution of actions on Unity's main thread. Unity requires that many of its API calls be made on the main thread, and this class provides a way to enqueue actions that need to be executed during the Unity game loop. This script is required by the WebControllerManager.</p>"},{"location":"UnityMainThreadDispatcher/#properties","title":"Properties","text":"<ul> <li>executionQueue: A private static queue that holds <code>Action</code> objects to be executed on the main thread.</li> </ul>"},{"location":"UnityMainThreadDispatcher/#methods","title":"Methods","text":"<ul> <li> <p>Update: This method runs every frame during Unity's game loop. It dequeues and executes all the actions that have been queued, ensuring that they are run on the main thread. </p> </li> <li> <p>Enqueue: This static method allows other components or threads to add actions to the queue for execution on the main thread. The actions are queued in a thread-safe manner.</p> </li> <li>Parameters:<ul> <li><code>action</code> (Action): The action to be executed on the main thread.</li> </ul> </li> </ul>"},{"location":"UnityMainThreadDispatcher/#thread-safety","title":"Thread Safety","text":"<ul> <li>The <code>executionQueue</code> is locked using a <code>lock</code> statement, ensuring that it is safe for use across multiple threads. This allows for actions to be enqueued from other threads (like background threads) while avoiding concurrency issues.</li> </ul>"},{"location":"WebControllerCommandParameters/","title":"WebControllerCommandParameters","text":"<p>The <code>WebControllerCommandParameters</code> class is a custom implementation of the <code>IReadOnlyDictionary&lt;string, object&gt;</code>, providing a read-only interface to a collection of key-value pairs where the keys are strings and the values are objects. It is designed to store command parameters received from WebController that are then processed as a parameter of a custom method, which is implemented as an action for received command.</p>"},{"location":"WebControllerCommandParameters/#usage-example","title":"Usage Example","text":"<pre><code>//Custom method for processing the received data \npublic void ReceiveDataFromServer(WebControllerCommandParameters parameters)\n{\n  // Accessing values by key\n  string username = (string)parameters[\"username\"];\n  int score = (int)parameters[\"score\"];\n\n  // Iterating through the parameters\n  foreach (var kvp in parameters)\n  {\n    Debug.Log($\"Key: {kvp.Key}, Value: {kvp.Value}\");\n  }\n}\n</code></pre> <p>Important: Dynamic input is accessible with the key <code>\"userInput\"</code>.</p> <p>This class provides an encapsulation for web controller command parameters, storing them in a read-only dictionary. It is a flexible solution for storing and passing around parameters that can be accessed by key while ensuring the integrity and immutability of the data once set.</p>"},{"location":"WebControllerManager/","title":"WebControllerManager","text":"<p>The WebControllerManager is a Unity MonoBehaviour class responsible for managing network communication between a Unity application and a server using Socket.IO. It handles:</p> <ul> <li>Connection and disconnection events</li> <li>Data transmission to the server</li> <li>Reconnection logic</li> <li>Heartbeat implementation to maintain connection</li> <li>Singleton pattern to ensure a single instance throughout the application</li> </ul>"},{"location":"WebControllerManager/#fields-and-properties","title":"Fields and Properties","text":"Type Name Description <code>string</code> <code>serverURL</code> URL of the server to connect to. <code>string</code> <code>port</code> Port number for the server connection. <code>bool</code> <code>useLocalhost</code> If true, overrides <code>serverURL</code> to use <code>http://localhost</code>. <code>string</code> <code>sessionName</code> Name of the session for identification. <code>bool</code> <code>debug</code> Enables debug logs if set to true. <code>float</code> <code>reconnectionTime</code> Time interval between reconnection attempts (in seconds). <code>static string</code> <code>deviceId</code> Unique identifier for the device. <code>static SocketIOUnity</code> <code>Socket</code> The Socket.IO client instance. <code>static eConnectionState</code> <code>ConnectionState</code> Current state of the network connection. <code>static Action</code> <code>OnConnected</code> Event invoked when connected. <code>static Action</code> <code>OnDisconnected</code> Event invoked when disconnected. <code>static Action</code> <code>OnConnecting</code> Event invoked when connecting. <code>static Action</code> <code>OnReconnecting</code> Event invoked when reconnecting. <code>static WebControllerManager</code> <code>Instance</code> Singleton instance of the manager."},{"location":"WebControllerManager/#enumerations","title":"Enumerations","text":"<p>eConnectionState: Represents the state of the WebSocket connection.</p> <ul> <li>Connected: The connection is active.</li> <li>Disconnected: The connection is inactive.</li> <li>Connecting: The connection is in the process of being established.</li> <li>Reconnecting: The connection is in the process of being re-established after a failure.</li> </ul>"},{"location":"WebControllerManager/#methods","title":"Methods","text":"<ul> <li>Init: Initializes the WebSocket connection and starts the connection attempt.</li> <li>Connect: Attempts to establish the WebSocket connection if disconnected.</li> <li>Update: Periodically checks if the connection is alive by sending ping messages and handling disconnections.</li> <li>Register: Sends registration data (device ID and session name) to the server to identify the device.</li> <li>SendData: Sends custom data to the server with a specified key and value.</li> <li>SendPositionData: Sends position data to the server.</li> <li>SetContext: Sends context data to the server (serialized as a JSON array).</li> <li>SendDataInternal: The internal method to send data to the server (called by the other <code>SendData</code> methods).</li> </ul>"},{"location":"WebControllerManager/#socket-events","title":"Socket Events","text":"<ul> <li>OnConnected: Triggered when a successful connection is made to the server.</li> <li>OnDisconnected: Triggered when the WebSocket connection is lost.</li> <li>pong: Listens for the \"pong\" event from the server to track the connection health.</li> <li>error: Logs errors encountered during socket communication.</li> <li>registered: Logs successful registration with the server.</li> </ul>"},{"location":"WebControllerManager/#pingpong-mechanism","title":"Ping/Pong Mechanism","text":"<ul> <li>The class sends a ping message to the server every 2 seconds.</li> <li>It expects a pong message from the server within 6 seconds. If the pong message is not received, the connection state is set to Disconnected, and a reconnection attempt is initiated.</li> </ul>"},{"location":"WebControllerManager/#lifecycle-and-cleanup","title":"Lifecycle and Cleanup","text":"<ul> <li>Awake: Ensures that only one instance of <code>WebControllerManager</code> exists. Initializes necessary components and calls <code>Init</code>.</li> <li>OnDestroy: Cleans up the WebSocket connection by disconnecting and disposing of the SocketIO client.</li> </ul>"},{"location":"WebControllerManager/#reconnection-logic","title":"Reconnection Logic","text":"<ul> <li> <p>If the WebSocket connection is lost, the <code>Update</code> method monitors the time since the last pong message. If the server does not respond within 6 seconds, the system tries to reconnect by calling <code>Connect</code>.</p> </li> <li> <p>The <code>Connect</code> method attempts to reconnect by calling <code>TryConnectWithDelay</code> with an interval defined by <code>reconnectionTime</code>.</p> </li> <li> <p>If the connection is successful, the <code>OnConnect</code> method is triggered, registering the device with the server again.</p> </li> </ul>"},{"location":"WebControllerManager/#sending-data-context","title":"Sending Data &amp; Context","text":"<p>To send data to the server, you can use the <code>SendData</code> method, which requires a <code>key</code> and a <code>value</code>. The <code>key</code> can be any string except <code>\"position\"</code> and <code>\"context\"</code>, as those are reserved for internal use. For example, to send a custom piece of data:</p> <pre><code>WebControllerManager.SendData(\"key_name\", \"value_data\");\n</code></pre> <p>To send context data, such as session-specific information, you can use the <code>SetContext</code> method. This method expects an array of strings, which will be serialized and sent as the <code>\"context\"</code>:</p> <pre><code>WebControllerManager.SetContext(new string[] { \"context_data1\", \"context_data2\" });\n</code></pre>"},{"location":"WebControllerManager/#connection-events","title":"Connection Events","text":"<p>The <code>WebControllerManager</code> provides several events related to the WebSocket connection status. These events help you manage the connection lifecycle:</p> <ul> <li><code>OnConnecting</code>: Triggered when the connection is in the process of being established.</li> </ul> <p><code>csharp   WebControllerManager.OnConnecting += () =&gt; Debug.Log(\"Connecting to the server...\");</code></p> <ul> <li><code>OnConnected</code>: Triggered once the connection is successfully established. You can use this event to handle actions after the connection is live.</li> </ul> <p><code>csharp   WebControllerManager.OnConnected += () =&gt; Debug.Log(\"Connected to the server!\");</code></p> <ul> <li><code>OnDisconnected</code>: Triggered when the connection is lost or the socket disconnects. Use this to handle disconnection scenarios.</li> </ul> <p><code>csharp   WebControllerManager.OnDisconnected += () =&gt; Debug.Log(\"Disconnected from the server.\");</code></p> <ul> <li><code>OnReconnecting</code>: Triggered when the system attempts to reconnect after losing the connection. You can use this event to notify users that a reconnection is in progress.</li> </ul> <p><code>csharp   WebControllerManager.OnReconnecting += () =&gt; Debug.Log(\"Reconnecting to the server...\");</code></p> <p>By subscribing to these events, you can keep track of the connection state and perform actions like UI updates or retry logic based on the connection status.</p>"},{"location":"WebControllerManager/#additional-notes","title":"Additional Notes","text":"<ul> <li>The <code>WebControllerManager</code> is designed to run as a singleton, ensuring there is only one instance managing the WebSocket connection.</li> <li>The <code>UnityMainThreadDispatcher</code> component is used to ensure that certain actions happen on the Unity main thread, as Unity\u2019s API must be accessed from the main thread.</li> <li>The <code>SocketIOUnity</code> library is used to manage WebSocket communication.</li> </ul>"},{"location":"app-py/","title":"Backend","text":"<p>Flask-based server in <code>app.py</code> provides real-time communication for managing and monitoring device sessions using WebSockets (via Flask-SocketIO). It supports both active and inactive sessions, session commands, and memory management. The server also integrates with a front-end Vue.js application for real-time updates of session statuses.</p>"},{"location":"app-py/#features","title":"Features","text":"<ul> <li>Session Management: Tracks both active and inactive sessions for devices, allowing for session registration, disconnection, and detailed information retrieval.</li> <li>Real-time Communication: Uses WebSockets for bidirectional communication between the server and clients (Vue.js frontend).</li> <li>Memory Management: Cleans up inactive sessions when the server detects low available memory.</li> <li>Data Handling: Allows real-time updates and manipulation of session data via commands and key-value pairs.</li> <li>Persistence: Saves inactive sessions to disk when they are no longer active, ensuring session data is not lost.</li> </ul>"},{"location":"app-py/#logic-overview","title":"Logic Overview","text":""},{"location":"app-py/#routes","title":"Routes","text":"<ul> <li><code>/</code>: The root route, returns a \"Server is running\" message.</li> <li><code>/test</code>: A test interface for sending commands to Unity.</li> </ul>"},{"location":"app-py/#global-variables","title":"Global Variables","text":"<ul> <li><code>sessions</code>: A dictionary tracking all active sessions, indexed by device ID.</li> <li><code>vue_sessions</code>: A set tracking the session IDs of connected Vue.js clients.</li> <li><code>max_history_cache</code>: A dictionary caching the maximum history size for session data keys.</li> <li><code>config</code>: Configuration data loaded from a <code>config.json</code> file.</li> </ul>"},{"location":"app-py/#session-dictionary-structure","title":"Session Dictionary Structure","text":"<p>Each session in the <code>sessions</code> dictionary follows this structure:</p> <pre><code>{\n    'session_name': str,     # Name of the session/application\n    'start_time': float,     # Timestamp when the session started\n    'last_ping': float,      # Timestamp of the last client data update\n    'data': dict,            # Dictionary to store data updates\n    'sid': str,              # Socket.IO session ID\n    'is_connected': bool     # Connection status\n}\n</code></pre>"},{"location":"app-py/#socketio-events","title":"Socket.IO Events","text":"<ul> <li><code>ping</code>: Sends a ping to the client and waits for a response (<code>pong</code>).</li> <li><code>connect</code>: Logs the client\u2019s connection with the server.</li> <li><code>disconnect</code>: Handles client disconnections and removes the session if it was registered.</li> <li><code>register_vue</code>: Registers the Vue.js client by adding its session ID (<code>sid</code>) to a global set.</li> <li><code>register</code>: Registers a new device session or reconnects an existing device session. It assigns the device a unique <code>sid</code> and sets the session as active.</li> <li><code>send_command</code>: Sends a command to the device with parameters.</li> <li><code>update_data</code>: Updates a session's data and ensures the data history is kept within the configured size.</li> <li><code>get_active_sessions</code>: Fetches all active sessions and sends them to the client.</li> <li><code>get_inactive_sessions</code>: Fetches all inactive sessions and sends them to the client.</li> <li><code>get_active_session</code>: Fetches the session of a device that is active.</li> <li><code>get_inactive_session</code>: Fetches the session of a device that is inactive.</li> <li><code>delete_session</code>: Deletes a session and its corresponding data from disk.</li> <li><code>session_data_key_update</code>: Sends updates to the frontend when session data changes.</li> </ul>"},{"location":"app-py/#session-management","title":"Session Management","text":"<ul> <li>Active Sessions: Devices that are currently connected and sending regular pings are considered active. These sessions are tracked in memory.</li> <li>Inactive Sessions: Devices that are disconnected but whose session data is still available are considered inactive. These sessions are stored in disk files for persistence (<code>INACTIVE_SESSIONS_DIR</code>).</li> <li>Session Registration: When a device connects, it registers with the server by sending a <code>register</code> event. If a session exists on disk, it's restored. If not, a new session is created.</li> <li>Session Commands: Device data can be updated using the <code>update_data</code> event, with the server managing the data's history size based on configuration.</li> </ul>"},{"location":"app-py/#persistence-mechanism","title":"Persistence Mechanism","text":"<p>Inactive sessions are saved to disk to persist their data when the device disconnects. These sessions are saved under the directory <code>INACTIVE_SESSIONS_DIR</code>. When a device reconnects, its session is loaded from disk if it exists.</p>"},{"location":"app-py/#memory-management","title":"Memory Management","text":"<ul> <li>Memory Monitoring: The server monitors available memory using the <code>psutil</code> library. If the available memory falls below a configured threshold, it will clean up inactive sessions to free up memory.</li> <li>Inactive Session Cleanup: The <code>cleanup_inactive_sessions</code> function sorts inactive sessions by the last ping time and removes them to ensure the server has sufficient free memory.</li> </ul>"},{"location":"app-py/#session-storage-functions","title":"Session Storage Functions","text":"<ul> <li><code>save_session_to_disk(device_id, session)</code>: Saves a session to disk (in <code>INACTIVE_SESSIONS_DIR</code>).</li> <li><code>load_session_from_disk(device_id)</code>: Loads a session from disk if it exists.</li> <li><code>get_active_sessions()</code>: Returns all active sessions.</li> <li><code>get_inactive_sessions()</code>: Returns all inactive sessions and loads any inactive session data from disk.</li> <li><code>emit_sessions_update()</code>: Emits the updated list of active and inactive sessions to all Vue clients.</li> </ul>"},{"location":"demo/","title":"Demo","text":"<p>To get familiar with the application, you can try the prepared demo. The demo consists of a Unity project and a configuration for the web application.</p> <p>The demo features a single scene where the player moves around a room collecting coins. When coins are collected, a message is sent to the server with information about the coin collection and the current number of coins collected. This data is displayed in the session detail of the web application. Using the control panel in the session detail, you can reset the player's position, reset the number of collected coins, or spawn any number of new coins. In the Unity project, the CoinManager script sends the current context for the buttons in the control panel, indicating whether the player has collected any coins or if the count is zero. Based on this, the button to reset the number of collected coins will either be displayed or hidden. The PositionSender script sends the player\u2019s position, which is displayed on the map in the session details.</p>"},{"location":"demo/#instructions","title":"Instructions","text":"<ol> <li>Download the Unity project from: <code>https://github.com/Rikib1999/WebControllerDEMO</code></li> <li>Copy the demo application configuration from the config.txt file in the demo to the configuration file of the web application.</li> <li>Download the map image DEMOmap.png and host it online (for example you can use the webpage <code>https://imgbb.com/upload</code>).</li> <li>Fill in the address of the hosted image into the web application config in the map section.</li> <li>Run the demo Unity project. The project consists of only one scene.</li> <li>Set up the connection in the WebControllerManager object by specifying the server address and port according to your web application.</li> <li>The project is ready; you can start testing.</li> </ol>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":""},{"location":"faq/#1-what-is-webcontroller","title":"1. What is WebController?","text":"<p>WebController is a web application designed for managing and monitoring Unity-based experiments. It allows users to track active and inactive game sessions, send commands, receive data, and view player positions on a map.</p>"},{"location":"faq/#2-what-components-does-webcontroller-use","title":"2. What components does WebController use?","text":"<p>WebController is built on a client-server architecture and consists of the following components:</p> <ul> <li>Frontend: Developed using Vue.js for displaying session details and providing interactive controls.</li> <li>Backend: A Flask application managing sessions and WebSocket communication.</li> <li>Unity Client: Unity game sessions that communicate with the server.</li> <li>Proxy Server: An NGINX reverse proxy for routing requests.</li> <li>Dockerized Environment: Components are containerized for easy deployment and scalability.</li> </ul>"},{"location":"faq/#3-how-do-i-install-webcontroller","title":"3. How do I install WebController?","text":""},{"location":"faq/#prerequisites","title":"Prerequisites:","text":"<p>Before starting, make sure you have the following installed:</p> <ul> <li>Docker</li> <li>Docker Compose</li> <li>Git</li> </ul>"},{"location":"faq/#steps","title":"Steps:","text":"<ol> <li> <p>Clone the repository:     <code>git clone https://github.com/cyberspace-lab/cyberframe-webcontroller.git     cd cyberframe-webcontroller</code></p> </li> <li> <p>Create and start Docker containers:     <code>docker-compose up --build</code>     This will build and start the application, including the Flask backend, Vue frontend, and NGINX reverse proxy.</p> </li> </ol>"},{"location":"faq/#4-how-do-i-configure-the-application","title":"4. How do I configure the application?","text":"<p>Configuration for each experiment is done in the config.json file located at ./vuefrontend/src/config.json.</p> <p>The file allows you to define:</p> <ul> <li>Control Buttons: Custom buttons for sending commands to Unity clients.</li> <li>Data Receivers: Defines the data expected from Unity clients.</li> <li>Levels: Map and level data, including size and calibration settings.</li> <li>Memory Settings: Minimum free memory percentage before cleaning inactive sessions.</li> </ul> <p>Example:</p> <pre><code>{\n  \"applications\": {\n    \"MoveDifferent\": {\n      \"controlButtons\": [\n        {\n          \"title\": \"Set participant name\",\n          \"requiresInput\": true,\n          \"inputPlaceholder\": \"Participant\",\n          \"payload\": {\n            \"eventName\": \"participantName\",\n            \"parameters\": {}\n          },\n          \"context\": [\"menu\"]\n        }\n      ],\n      \"receivers\": [\n        {\n          \"currentScene\": { \"maxHistory\": 10 },\n          \"location\": { \"maxHistory\": 20 },\n          \"position\": { \"maxHistory\": 10 }\n        }\n      ],\n      \"levels\": [\n        {\n          \"1\": {\n            \"url\": \"https://example.com/map.png\",\n            \"realWidth\": 25.5,\n            \"realHeight\": 26.5,\n            \"mapOffsetX\": -0.7,\n            \"mapOffsetY\": 3.3,\n            \"mapOffsetRotation\": -90\n          }\n        }\n      ]\n    }\n  },\n  \"min_free_memory_percentage\": 20\n}\n</code></pre>"},{"location":"faq/#5-how-do-i-view-active-and-inactive-sessions","title":"5. How do I view active and inactive sessions?","text":""},{"location":"faq/#active-sessions","title":"Active Sessions:","text":"<p>You can view the list of active sessions by navigating to:</p> <pre><code>{APPLICATION_URL}/activesessions\n</code></pre> <p>Here, you can see details about currently active game sessions, including:</p> <ul> <li>Session name</li> <li>Device ID</li> <li>Connection time</li> <li>Last data update time</li> </ul>"},{"location":"faq/#inactive-sessions","title":"Inactive Sessions:","text":"<p>Inactive sessions can be viewed at:</p> <pre><code>{APPLICATION_URL}/inactivesessions\n</code></pre> <p>You can view historical data for inactive sessions and remove them from the server.</p>"},{"location":"faq/#6-how-do-i-interact-with-unity-game-sessions","title":"6. How do I interact with Unity game sessions?","text":"<p>You can send commands to Unity game sessions from the Control Panel on the active session detail page. Each button is associated with a specific command, and if the command requires input, you can enter it in the provided input field.</p> <p>Commands are defined in the config.json file and include parameters, such as starting or stopping the experiment or setting participant information.</p>"},{"location":"faq/#7-how-does-position-tracking-work","title":"7. How does position tracking work?","text":"<p>The application can track the positions of players and objects in the game world. To enable position tracking, you need to define a position data receiver in the config.json file.</p> <p>The position of players and objects is displayed on the map in real-time, with a history of past positions. The map updates automatically when the level changes.</p> <p>Positions are shown as dots with arrows indicating rotation, and the path of movement is drawn by connecting the positions.</p>"},{"location":"faq/#8-how-can-i-test-the-application-with-fake-data","title":"8. How can I test the application with fake data?","text":"<p>You can test the frontend and backend communication with fake data by visiting:</p> <pre><code>http://localhost:4000/test\n</code></pre> <p>Here, you can simulate fake sessions and send fake data to specific sessions by providing a fake experiment name and device ID.</p>"},{"location":"faq/#9-how-do-i-integrate-unity-with-webcontroller","title":"9. How do I integrate Unity with WebController?","text":"<p>To integrate Unity with WebController, you'll need to:</p> <p>Add the Unity package (which includes several scripts) to your project. Use the WebControllerManager script to connect your Unity project to the server. This script should be attached to a GameObject in the main scene. Use the SendData() method to send data to the server and the GenericEventListener script to listen for commands from the server. Use the PositionSender script to send position data for objects and players. For detailed instructions, refer to the Unity Integration section.</p>"},{"location":"faq/#10-how-can-i-remove-inactive-sessions-from-the-server","title":"10. How can I remove inactive sessions from the server?","text":"<p>On the detail page of an inactive session, you'll find an option to remove the session from the server. This action is permanent and cannot be undone.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation-and-setup","title":"Installation and Setup","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Docker and Docker Compose</li> <li>Git (to clone the repository)</li> </ul>"},{"location":"getting-started/#docker-setup","title":"Docker Setup","text":"<ol> <li> <p>Clone the Repository</p> <p><code>git clone https://github.com/cyberspace-lab/cyberframe-webcontroller.git</code></p> <p><code>cd webcontroller</code></p> </li> <li> <p>Build and Run the Docker Containers</p> <p><code>docker-compose up --build</code></p> <p>This command will:</p> <ul> <li>Build the Flask backend and Vue frontend images.</li> <li>Start the Nginx reverse proxy.</li> <li>Expose the necessary ports.</li> </ul> </li> </ol> <p>Now you can access the application at the address <code>{APPLICATION_ADDRESS}/activesessions</code> where a list of all currently connected game sessions will be displayed.</p>"},{"location":"getting-started/#application-configuration","title":"Application Configuration","text":"<p>The application needs to be configured for each experiment in the file <code>./vue-frontend/src/config.json</code>, which follows this structure:</p> <ul> <li>applications: A dictionary of applications with their specific settings.</li> <li> <p>Application Name (e.g., <code>\"MoveDifferent\"</code>):</p> <ul> <li>controlButtons: Defines buttons that send commands to Unity clients.</li> <li>receivers: Specifies data keys and history limits expected from Unity clients. Just a list of names of data types that are expected to be recieved from Unity app and will be shown in the session detail.</li> <li>levels: Contains details about levels/scenes, including map images and real-world dimensions.</li> </ul> </li> <li> <p>min_free_memory_percentage: The minimum percentage of free memory required before cleaning up inactive sessions begins.</p> </li> </ul>"},{"location":"getting-started/#button-definition","title":"Button Definition","text":"<p>Each button has the following properties:</p> <ul> <li>title: The button's label.</li> <li>requiresInput: Indicates if the button requires dynamic input for parameters.</li> <li>inputPlaceholder: Placeholder text for the input field.</li> <li>payload:<ul> <li>eventName: The name of the command.</li> <li>parameters: Parameters for the command.</li> </ul> </li> <li>context: A list of context names in which the button will appear. If left empty, the button will always be visible.</li> </ul> <p>Important: Dynamic input parameter is accessible in the Unity with the key <code>\"userInput\"</code>.</p>"},{"location":"getting-started/#data-definition","title":"Data Definition","text":"<ul> <li>Data Type Name (e.g., <code>currentScene</code>):</li> <li>maxHistory: The number of previous records to store (default is 10).</li> </ul> <p>If you want to display a level map and track player positions, you must define the data type <code>position</code>. This type is internal, other types are be custom.</p>"},{"location":"getting-started/#level-map-definition","title":"Level Map Definition","text":"<p>Each level map is defined with the following properties:</p> <ul> <li>Level Index (e.g., \"1\"):<ul> <li>url: The URL of the map image.</li> <li>realWidth: The actual width of the map in Unity units.</li> <li>realHeight: The actual height of the map in Unity units.</li> <li>mapOffsetX: Offset for the x-coordinate to calibrate positions.</li> <li>mapOffsetY: Offset for the y-coordinate to calibrate positions.</li> <li>mapOffsetRotation: Offset for rotation (in degrees) to calibrate positions.</li> </ul> </li> </ul>"},{"location":"getting-started/#configuration-example","title":"Configuration Example","text":"<pre><code>{\n  \"applications\": {\n    \"MoveDifferent\": {\n      \"controlButtons\": [\n        {\n          \"title\": \"Set participant name\",\n          \"requiresInput\": true,\n          \"inputPlaceholder\": \"Participant\",\n          \"payload\": {\n            \"eventName\": \"participantName\",\n            \"parameters\": {}\n          },\n          \"context\": [\"menu\"]\n        },\n        {\n          \"title\": \"Start Test Teleport\",\n          \"payload\": {\n            \"eventName\": \"startLevel\",\n            \"parameters\": { \"settingsIndex\": 0 }\n          },\n          \"context\": [\"menu\"]\n        },\n        {\n          \"title\": \"Start/Stop Experiment\",\n          \"payload\": {\n            \"eventName\": \"startStopExperiment\",\n            \"parameters\": {}\n          },\n          \"context\": [\"level\"]\n        }\n      ],\n      \"receivers\": [\n        {\n          \"currentScene\":{ \"maxHistory\": 10 },\n          \"location\":{ \"maxHistory\": 20 },\n          \"position\":{ \"maxHistory\": 10 }\n        }\n      ],\n      \"levels\": [\n        {\n          \"1\": {\n            \"url\": \"https://i.ibb.co/PCLSBCJ/map-dungeon.png\",\n            \"realWidth\": 25.5,\n            \"realHeight\": 26.5,\n            \"mapOffsetX\": -0.7,\n            \"mapOffsetY\": 3.3,\n            \"mapOffsetRotation\": -90\n          }\n        }\n      ]\n    }\n  },\n  \"min_free_memory_percentage\": 20\n}\n\n</code></pre>"},{"location":"getting-started/#integration-of-unity-package","title":"Integration of Unity Package","text":"<p>WebController Unity package facilitates communication between the game session and the server. This package includes five scripts, which need to be added to the Unity project. It requires the Socket.IO library, which can be downloaded via the Package Manager in Unity using the link: <code>https://github.com/itisnajim/SocketIOUnity.git</code>.</p> <p></p>"},{"location":"getting-started/#key-script-webcontrollermanager","title":"Key Script: WebControllerManager","text":"<p>This is the main script of the package and must be attached to an object in the main starting scene of the project. Subsequent scenes should be accessed from this starting scene. The object with WebControllerManager persists across scenes, ensuring only one instance exists throughout the project.</p> <p>Configuration in Inspector:</p> <ul> <li>serverURL: URL of the server (e.g., <code>http://localhost</code>).</li> <li>port: Server port. Default port is 4000.</li> <li>sessionName: Name of the experiment session.</li> <li>reconnectionTime: Time interval (in seconds) for retrying server connections after disconnection.</li> <li>Debug options:<ul> <li><code>debug</code>: Logs connection-related messages to the Unity console.</li> <li><code>useLocalhost</code>: Overrides <code>serverURL</code> with <code>http://localhost</code>.</li> </ul> </li> </ul> <p></p> <p>If <code>sessionName</code> is not provided, the app uses the Unity project name as the default experiment name.</p> <p>Important: The experiment name must match the application name set in the web app configuration.</p> <p>Once configured, the game session automatically connects to the server.</p>"},{"location":"getting-started/#sending-data-to-the-server","title":"Sending Data to the Server","text":"<p>To send data, call the static method:</p> <pre><code>WebControllerManager.SendData(string key, string value);\n</code></pre> <ul> <li><code>key</code>: The data type name, matching the one defined in the web app configuration under <code>receivers</code>.<ul> <li>Reserved keys: <code>position</code> and <code>context</code> (cannot be used).</li> </ul> </li> <li><code>value</code>: The data value, provided as a string.</li> </ul> <p>Data will be displayed in the session detail page.</p> <p>Example:</p> <pre><code>public void TakeDamage(int damage)\n{\n  this.health -= damage;\n  WebControllerManager.SendData(\"damage_taken\", damage);\n\n  if (this.health &lt;= 0)\n  {\n    WebControllerManager.SendData(\"player_event\", \"Player was killed\");\n    KillPlayer();\n  }\n}\n</code></pre>"},{"location":"getting-started/#receiving-commands-from-the-server","title":"Receiving Commands from the Server","text":"<p>By clicking a button in the control panel of a session detail page in the web application, the server will send a command with parameters to the Unity session.</p> <p>To handle commands from the server:</p> <ol> <li>Attach the GenericEventListener script to an object in the scene.</li> <li>In the Inspector, configure the <code>events</code> section:<ul> <li>Define the event name (matching the button configuration in the web app).</li> <li>Assign an action (method to be called when the command is received).</li> </ul> </li> </ol> <p></p> <p>Supported Method Types:</p> <ul> <li>Without parameters.</li> <li>With a single parameter of type <code>WebControllerCommand</code> (a wrapper for a dictionary).</li> </ul> <p>If the command includes parameters, extract them from the dictionary using the parameter name (key). The values are of type <code>object</code>.</p> <p>Example:</p> <pre><code>public void ReceiveParticipantName(WebControllerCommandParameters parameters)\n{\n  string name = (string)parameters[\"name\"];\n  this.textbox.text = name;\n}\n\npublic void SetAndStartLevel(WebControllerCommandParameters parameters)\n{\n  int levelID = (int)parameters[\"levelID\"];\n  Logger.Log(\"Starting level with ID:\" + levelID);\n  StartLevel(levelID);\n}\n\n//example of method without parameter\npublic void ResetPlayersPosition()\n{\n  player.transform.position = new Vector3(0, 0, 0);\n}\n</code></pre> <p>Important: Dynamic input is accessible with the key <code>\"userInput\"</code>.</p>"},{"location":"getting-started/#changing-contexts-for-buttons","title":"Changing Contexts for Buttons","text":"<p>Buttons in the control panel of a detail of a session in the web application can have some context defined in which they will be shown.</p> <p>To set these contexts call the static method:</p> <pre><code>WebControllerManager.SetContext(string[] values);\n</code></pre> <ul> <li><code>values</code>: An array of current context names.</li> <li>Buttons in the web app with at least one matching context name (or no defined context) will be displayed.</li> </ul> <p>Example:</p> <pre><code>WebControllerManager.SetContext(new string[] { \"menu\", \"player_controls\" });\n</code></pre>"},{"location":"getting-started/#sending-player-and-object-positions","title":"Sending Player and Object Positions","text":"<p>To send positions that will be shown in realtime on the map in the web application:</p> <ol> <li>Attach the PositionSender script to an empty object in the scene.</li> <li>Configure in the Inspector:<ul> <li>currentLevelID: Identification number for the current level. This ID will be used in the web application for selecting the correct map image.</li> <li>intervalInSeconds: Interval (in seconds) for sending positions.</li> <li>transformTrackings: List of objects to track, including:<ul> <li>References to the objects.</li> <li>Colors for the last position, previous positions, and movement trails.</li> </ul> </li> </ul> </li> </ol> <p></p> <p>This setup ensures seamless communication and integration between Unity projects and the server, enabling real-time interaction, data sharing, and experiment management.</p>"},{"location":"manual/","title":"Manual","text":""},{"location":"manual/#active-session-list","title":"Active Session List","text":"<p>At the address <code>\"{APPLICATION_ADDRESS}/activesessions\"</code>, you can view a list of all currently connected game sessions. The list contains the name of the session, the device identification number on which the game session is running, the connection time, and the last data update time. By clicking on a session item, you will be redirected to its details page. Clicking on the button in the top right corner, \"VIEW INACTIVE SESSIONS,\" will redirect you to the list of inactive game sessions.</p> <p></p>"},{"location":"manual/#inactive-session-list","title":"Inactive Session List","text":"<p>At the address <code>\"{APPLICATION_ADDRESS}/inactivesessions\"</code>, you can view a list of all past game sessions that are currently disconnected. The list contains the session name, the device identification number on which the game session was running, the connection time, and the last data update time. By clicking on a session item, you will be redirected to its details page. Clicking on the button in the top right corner, \"VIEW ACTIVE SESSIONS,\" will redirect you to the list of active game sessions.</p> <p></p>"},{"location":"manual/#active-session-detail","title":"Active Session Detail","text":"<p>The game session details are available by clicking on a session from the list of active game sessions. The page is divided into four parts:</p> <ul> <li>In the top left corner, you can see the experiment name, the device identification number on which the game session is running, the connection time, the last data update time, a button to return to the active session list, and a button to save the game session data in JSON format.</li> <li>In the bottom left part, there is a map of the current level, including the positions and rotations of the monitored players and levels. The map updates in real-time.</li> <li>In the top right part, there is a control panel with buttons for commands defined in the configuration file. When a button is clicked, the corresponding command is sent to the game session. If the command has a dynamic parameter, a text box will appear next to the button where you can input the parameter, and then click the button to send it.</li> <li>In the bottom right part, there is a list of all received data from the game session except for the position (which is displayed on the map or can be downloaded with the other session data). To show or hide previous received data, you must click on the specific data. The received data updates in real-time.</li> </ul> <p></p>"},{"location":"manual/#inactive-session-detail","title":"Inactive Session Detail","text":"<p>The details of an inactive game session are available by clicking on a session from the list of inactive game sessions. It is the same as the details of an active game session except for two differences:</p> <ul> <li>The control panel is not displayed because a disconnected session cannot be controlled.</li> <li>A button is added to delete the game session from the server's memory and disk. Deletion is irreversible.</li> </ul> <p></p>"},{"location":"manual/#control-panel","title":"Control Panel","text":"<p>The control panel is located in the top right corner of the active game session details page. All buttons for the current context are displayed here. If the button expects a parameter to be filled, a text box will appear next to it where the parameter can be entered. When clicked, the button\u2019s command, possibly along with the parameter, will be sent to the server. The parameter can be dynamic from the text box or static, as defined in the configuration file. The command may be without a parameter or, in the case of a static parameter, there may be several.</p> <p></p>"},{"location":"manual/#map-and-position-tracking","title":"Map and Position Tracking","text":"<p>The map is displayed in the bottom left part of the session details page. It shows the positions and rotations of all monitored players and objects in real-time. When the level changes, the map image updates automatically. To display the map, it is necessary to define the type of incoming data as \"position\" in the configuration file. The map shows the latest positions as well as several previous positions, the number of which can be defined in the configuration. Positions are connected by a line that represents the movement path. Each position is shown as a dot with an arrow indicating the rotation. Older positions are always drawn with smaller dots and arrows. In the Unity package, you can define different colors for each monitored object and also different colors for the latest position, older positions, and the movement path. The Unity package also defines the interval for sending positions.</p> <p></p>"},{"location":"manual/#testing-with-fake-data","title":"Testing with Fake Data","text":"<p>The communication between the frontend and the backend, as well as data display on the frontend, can be easily tested at the address <code>http://localhost:4000/test</code> during local development. By filling in a fake experiment name and fake device identification number, you can create a fake session on the server. You can also send fake data to a specific session based on the device identification number.</p> <p></p>"}]}